# 位运算

> 只有整形才能进行二进制运算，在算法竞赛里面的作用：优化

## 常用运算符

- ![](https://gitee.com/constsheng/imgcurl/raw/master/img/20210309082124.png)

1. **与操作：&**

   > 简单概括为有 0 则 0
   >
   > 理解：与是表示上下同位都为1时才为真，所以如果出现0则就为假

2. **并操作：|**

   > 简单理解为有 1 则 1
   >
   > 理解：或操作类似平时用的条件或 || 即如果有一位为真，则就全部为真

3. **异或操作：^**

   > 对应位相同时为0，对应位不同时为1

4. **求补操作：~**

   > 按位取反

5. **左移：>>**

   > 左移相当于将 01011001 变成 0101100 
   >
   > 即最后一位被杀掉，在实际意义上表示 除 2

6. **右移：>>**

   > 右移相当于将 01011001 变成 010110010
   >
   > 即新增一位 0 ，实际意义上表示 乘 2

   

## 运用及例题：

**运用1. 求 n 的第 k 位数字 ： n >> k & 1 见例 1：**

> *   先把第 k 位移到最后一位， `n >> k`
> *   看个位是几， `x & 1`
> *   一般俩说都是合并起来一起写 n >> k & 1

**运用2. lowbit(n) = n & -n : 返回 n 的二进制形式的最后 1 位是多少**  
简称返回 n 的最后一位

> *   -x = ~x + 1
> *   x & -x = x & (~x + 1)

例 1：

```cpp
int main() {
    int n = 10;
    for (int k = 3; k >= 0; k-- ) cout << (n >> k & 1); //结果是1010
    // 类似队列，先入先出，10的二进制表示为1010，实际上也是先输出左边第一个1，再0，再1，再0
    return 0;
}
```

例 2：（本题完整代码）

> *   方法：  
>     统计 x 中 1 的个数：每次把最后的 1 去掉（减掉），当 x=0，里面没有 1 时，统计减了多少次，就有多少个 1

```cpp
#include <iostream>
#include <cstdio>

using namespace std;

int lowbit(int x) { //返回x的二进制形式的的最后一位1是多少
    return x & -x;
}

int main() {
    int n;
    cin >> n;
    while (n--) {
        int x;
        cin >> x;
        int res = 0;
        while (x)   x -= lowbit(x), res++; //每次减去x的最后一位1
        cout << res << ' ';
    }
    return 0;
}
```