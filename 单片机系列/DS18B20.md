[toc]

> https://www.xmf393.com/2019/08/18/20190801801/
>
> https://www.xmf393.com/2019/08/17/2019081701/



# 温度转换与读取流程

- > ![](https://gitee.com/constsheng/imgcurl/raw/master/img/20210525103104.png)

# DS18B20的数据处理

1. DS18B20以16位带符号位扩展的二进制`补码`形式读出
2. 低四位为小数部分，中间七位为整数部分，高五位为符号位
3. DS18B20的分辨率为`0.0625`.
   - 读出数据位`正温度`时，将LSB和MSB整合的16位整数，直接乘0.0625.
   - `负温度`，将LSB和MSB整合成的16位整数，取反加1后，再乘以0.0625

> 注意：在上电复位时，`温度寄存器`中的值为0x0550，即85度
>
> (转化没有成功)



# 解题思路

<1> 先将 **onewire.c**文件和**onewire.h**文件拷贝到当前工程下。
<2> 打开 **onewire.h**文件，检查文件代码是否完整，并确认总线引脚定义是否和CT107D的硬件对应，即P1^4。如果不对应，则将其修改过来。
<3> 打开 **onewire.c**文件， 研读各个底层驱动代码的具体实现，初步判断是时序的延时是否合理，如有明显错误，则将其修改过来。
<4> 根据DS18B20的工作原理和操作流程，编写读取温度结果和处理温度数据的函数，这是进行DS18B20应用开发中最重要的一个环节。
<5> 根据得到的温度结果，刷新数码管显示。这个部分，可以用MM模式来实现，可以用IO模式来实现。

# 代码示例

```cpp
//DS18B20温度采样与结果处理参考代码
void Read_Temperature()
{
	unsigned char LSB,MSB ;
	
	Init_DS18B20();		      		 //DS18B20复位	
	Write_DS18B20(0xCC);	     	 //跳过ROM操作指令
	Write_DS18B20(0x44);           //开始温度转换
	Delay(1000);                //延时700ms左右，等待温度转换完成
	Init_DS18B20();		          //DS18B20复位
	Write_DS18B20(0xCC);	        //跳过ROM操作指令	
	Write_DS18B20(0xBE);	        //开始读取高速暂存器		
	LSB = Read_DS18B20();	       //读取温度数据的低8位
	MSB = Read_DS18B20();	       //读取温度数据的高8位
	Init_DS18B20();		       //DS18B20复位，停止暂存器数据读取

	T_dat = 0x0000;
	T_dat = MSB;
	T_dat <<= 8;
	T_dat = T_dat | LSB;          //将LSB和MSB整合成为一个16位的整数
	//首先通过温度数据的高5位判断采用结果是正温度还是负温度
	if((T_dat & 0xf800) == 0x0000)    //正温度的处理办法
	{
		T_dat >>= 4;         //取出温度结果的整数部分
		T_dat = T_dat*10;    //放大10倍，然后加上小数部分
		T_dat = T_dat + (LSB&0x0f)*0.625;
	}
}
```

